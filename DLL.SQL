

-- =====================================================================================
--  SEGURIDAD / AUDITORÍA
-- =====================================================================================

CREATE TABLE roles (
  id_rol          NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre_rol      VARCHAR2(50)  NOT NULL UNIQUE,
  descripcion     VARCHAR2(200),
  estado          CHAR(1) DEFAULT 'A' CHECK (estado IN ('A','I')),
  fecha_creacion  TIMESTAMP DEFAULT SYSTIMESTAMP
);

CREATE TABLE permisos (
  id_permiso      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre_permiso  VARCHAR2(80)  NOT NULL,
  categoria       VARCHAR2(40),
  estado          CHAR(1) DEFAULT 'A' CHECK (estado IN ('A','I')),
  fecha_creacion  TIMESTAMP DEFAULT SYSTIMESTAMP,
  CONSTRAINT uq_permiso UNIQUE (nombre_permiso, categoria)
);

CREATE TABLE roles_permisos (
  id_rol      NUMBER NOT NULL,
  id_permiso  NUMBER NOT NULL,
  PRIMARY KEY (id_rol, id_permiso),
  CONSTRAINT fk_rp_rol     FOREIGN KEY (id_rol)     REFERENCES roles(id_rol),
  CONSTRAINT fk_rp_permiso FOREIGN KEY (id_permiso) REFERENCES permisos(id_permiso)
);

CREATE TABLE empresas (
  id_empresa      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre          VARCHAR2(120) NOT NULL UNIQUE,
  estado          CHAR(1) DEFAULT 'A' CHECK (estado IN ('A','I')),
  fecha_creacion  TIMESTAMP DEFAULT SYSTIMESTAMP
);

CREATE TABLE usuarios (
  id_usuario        NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre            VARCHAR2(120) NOT NULL,
  usuario           VARCHAR2(60)  NOT NULL UNIQUE,
  email             VARCHAR2(120) NOT NULL UNIQUE,
  contrasena_hash   VARCHAR2(200) NOT NULL,
  telefono          VARCHAR2(20),
  estado            CHAR(1) DEFAULT 'A' CHECK (estado IN ('A','I')),
  fecha_creacion    TIMESTAMP DEFAULT SYSTIMESTAMP,
  fecha_ultimo_acceso TIMESTAMP
);

CREATE TABLE usuarios_empresas (
  id_usuario   NUMBER NOT NULL,
  id_empresa   NUMBER NOT NULL,
  id_rol       NUMBER NOT NULL,
  PRIMARY KEY (id_usuario, id_empresa),
  CONSTRAINT fk_ue_usuario FOREIGN KEY (id_usuario) REFERENCES usuarios(id_usuario),
  CONSTRAINT fk_ue_empresa FOREIGN KEY (id_empresa) REFERENCES empresas(id_empresa),
  CONSTRAINT fk_ue_rol     FOREIGN KEY (id_rol)     REFERENCES roles(id_rol)
);

CREATE TABLE log_sesiones (
  id_sesion     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_usuario    NUMBER NOT NULL,
  ip_origen     VARCHAR2(64),
  dispositivo   VARCHAR2(100),
  descripcion   VARCHAR2(200),
  fecha_inicio  TIMESTAMP DEFAULT SYSTIMESTAMP,
  fecha_cierre  TIMESTAMP,
  estado        VARCHAR2(20), -- ex: INICIADA, CERRADA, EXPIRADA
  CONSTRAINT fk_logs_user FOREIGN KEY (id_usuario) REFERENCES usuarios(id_usuario)
);

CREATE TABLE log_actividades (
  id_log        NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_usuario    NUMBER NOT NULL,
  modulo        VARCHAR2(60),
  accion        VARCHAR2(60),
  objeto        VARCHAR2(120),
  descripcion   VARCHAR2(400),
  ip_origen     VARCHAR2(64),
  fecha_accion  TIMESTAMP DEFAULT SYSTIMESTAMP,
  CONSTRAINT fk_logact_user FOREIGN KEY (id_usuario) REFERENCES usuarios(id_usuario)
);

-- Opcional: secciones / asignaciones específicas por UI
CREATE TABLE secciones_usuario (
  id_seccion       NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_usuario       NUMBER NOT NULL,
  nombre_seccion   VARCHAR2(80) NOT NULL,
  descripcion      VARCHAR2(200),
  fecha_asignacion TIMESTAMP DEFAULT SYSTIMESTAMP,
  CONSTRAINT fk_secc_user FOREIGN KEY (id_usuario) REFERENCES usuarios(id_usuario)
);

-- =====================================================================================
--  PARÁMETROS, RESPALDOS Y REPORTES
-- =====================================================================================

CREATE TABLE parametros_sistema (
  id_parametro       NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre_parametro   VARCHAR2(80) NOT NULL UNIQUE,
  valor_parametro    VARCHAR2(400),
  tipo_parametro     VARCHAR2(30), -- STRING, NUMBER, JSON, BOOL
  descripcion        VARCHAR2(300),
  usuario_modificacion VARCHAR2(120),
  fecha_modificacion TIMESTAMP DEFAULT SYSTIMESTAMP,
  estado             CHAR(1) DEFAULT 'A' CHECK (estado IN ('A','I'))
);

CREATE TABLE backup_logs (
  id_backup    NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tipo_backup  VARCHAR2(30), -- FULL, INCR, EXPORT
  fecha_backup TIMESTAMP DEFAULT SYSTIMESTAMP,
  ruta_archivo VARCHAR2(300),
  tamano_mb    NUMBER(12,2),
  usuario_ejecuta VARCHAR2(120),
  resultado    VARCHAR2(30), -- OK/ERROR
  detalle_error VARCHAR2(400),
  fecha_creacion TIMESTAMP DEFAULT SYSTIMESTAMP
);

CREATE TABLE tipo_reporte (
  id_tipo_reporte  NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre_reporte   VARCHAR2(120) NOT NULL,
  descripcion      VARCHAR2(300),
  sql_base         CLOB,                 -- consulta base parametrizable
  categoria        VARCHAR2(60),
  estado           CHAR(1) DEFAULT 'A' CHECK (estado IN ('A','I')),
  fecha_creacion   TIMESTAMP DEFAULT SYSTIMESTAMP
);

CREATE TABLE reportes_generados (
  id_reporte_generado NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_tipo_reporte     NUMBER NOT NULL,
  id_usuario          NUMBER NOT NULL,
  parametros_json     CLOB,
  ruta_archivo        VARCHAR2(300),
  formato_salida      VARCHAR2(30), -- PDF, XLSX, CSV
  estado              VARCHAR2(30), -- GENERADO, ERROR
  fecha_creacion      TIMESTAMP DEFAULT SYSTIMESTAMP,
  CONSTRAINT fk_rg_tipo  FOREIGN KEY (id_tipo_reporte) REFERENCES tipo_reporte(id_tipo_reporte),
  CONSTRAINT fk_rg_user  FOREIGN KEY (id_usuario)      REFERENCES usuarios(id_usuario)
);

-- =====================================================================================
--  MAESTROS: CATEGORÍAS / PROVEEDORES / ALMACENES / CLIENTES / DESCUENTOS
-- =====================================================================================

CREATE TABLE categoria_producto (
  id_categoria     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre_categoria VARCHAR2(100) NOT NULL UNIQUE,
  codigo_categoria VARCHAR2(6)   NOT NULL UNIQUE,   -- p/ SKU
  descripcion      VARCHAR2(200),
  estado           CHAR(1) DEFAULT 'A' CHECK (estado IN ('A','I')),
  fecha_creacion   TIMESTAMP DEFAULT SYSTIMESTAMP
);

CREATE TABLE proveedores (
  id_proveedor    NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre_proveedor VARCHAR2(120) NOT NULL,
  contacto        VARCHAR2(120),
  telefono        VARCHAR2(25),
  email           VARCHAR2(120),
  direccion       VARCHAR2(200),
  cedula_juridica VARCHAR2(40),
  estado          CHAR(1) DEFAULT 'A' CHECK (estado IN ('A','I')),
  fecha_registro  TIMESTAMP DEFAULT SYSTIMESTAMP
);

CREATE TABLE almacenes (
  id_almacen     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre_almacen VARCHAR2(100) NOT NULL UNIQUE,
  responsable    VARCHAR2(120),
  telefono       VARCHAR2(25),
  direccion      VARCHAR2(200),
  estado         CHAR(1) DEFAULT 'A' CHECK (estado IN ('A','I')),
  fecha_creacion TIMESTAMP DEFAULT SYSTIMESTAMP
);

CREATE TABLE clientes (
  id_cliente      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre_cliente  VARCHAR2(120) NOT NULL,
  cedula          VARCHAR2(40),
  telefono        VARCHAR2(25),
  email           VARCHAR2(120),
  direccion       VARCHAR2(200),
  fecha_registro  TIMESTAMP DEFAULT SYSTIMESTAMP,
  estado          CHAR(1) DEFAULT 'A' CHECK (estado IN ('A','I'))
);

CREATE TABLE descuentos (
  id_descuento     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre_descuento VARCHAR2(120) NOT NULL,
  tipo_descuento   VARCHAR2(20)  NOT NULL, -- PORCENTAJE, MONTO
  valor_descuento  NUMBER(12,2)  NOT NULL CHECK (valor_descuento >= 0),
  fecha_inicio     DATE,
  fecha_fin        DATE,
  id_producto      NUMBER,                 -- opcional por producto
  estado           CHAR(1) DEFAULT 'A' CHECK (estado IN ('A','I')),
  fecha_creacion   TIMESTAMP DEFAULT SYSTIMESTAMP
);

-- =====================================================================================
--  PRODUCTOS (con SKU automático ZHN-<CODCAT>-<#####>)
-- =====================================================================================

CREATE TABLE productos (
  id_producto     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  codigo_producto VARCHAR2(24) UNIQUE,           -- SKU
  nombre_producto VARCHAR2(150) NOT NULL,
  descripcion     VARCHAR2(400),
  precio_venta    NUMBER(12,2) DEFAULT 0 NOT NULL CHECK (precio_venta >= 0),
  precio_compra   NUMBER(12,2) DEFAULT 0 NOT NULL CHECK (precio_compra >= 0),
  stock           NUMBER(12,2) DEFAULT 0 NOT NULL CHECK (stock >= 0),
  unidad_medida   VARCHAR2(20),
  id_categoria    NUMBER NOT NULL,
  id_proveedor    NUMBER,
  id_almacen      NUMBER,
  estado          CHAR(1) DEFAULT 'A' CHECK (estado IN ('A','I')),
  fecha_creacion  TIMESTAMP DEFAULT SYSTIMESTAMP,
  fecha_actualizacion TIMESTAMP,
  CONSTRAINT fk_prod_cat  FOREIGN KEY (id_categoria) REFERENCES categoria_producto(id_categoria),
  CONSTRAINT fk_prod_prov FOREIGN KEY (id_proveedor) REFERENCES proveedores(id_proveedor),
  CONSTRAINT fk_prod_alma FOREIGN KEY (id_almacen)   REFERENCES almacenes(id_almacen)
);

-- Secuencia para el consecutivo del SKU
CREATE SEQUENCE seq_sku START WITH 1 INCREMENT BY 1 NOCACHE;

-- Función para generar SKU: ZHN-<CODCAT>-<#####> CORRER COMO SYSDBA O USUARIO CON PRIVILEGIOS
CREATE OR REPLACE FUNCTION fn_gen_sku(p_id_categoria NUMBER) 
RETURN VARCHAR2
IS
  v_cod categoria_producto.codigo_categoria%TYPE;
  v_num NUMBER;
BEGIN
  SELECT codigo_categoria INTO v_cod
    FROM categoria_producto
   WHERE id_categoria = p_id_categoria;

  v_num := seq_sku.NEXTVAL;
  RETURN 'ZHN-' || v_cod || '-' || LPAD(v_num, 5, '0');
END;
/
SHOW ERRORS;

CREATE OR REPLACE TRIGGER trg_prod_sku_bi
BEFORE INSERT ON productos
FOR EACH ROW
BEGIN
  IF :NEW.codigo_producto IS NULL THEN
    :NEW.codigo_producto := fn_gen_sku(:NEW.id_categoria);
  END IF;
END;
/
SHOW ERRORS;

-- Trigger: autogenerar SKU si viene NULL
CREATE OR REPLACE TRIGGER trg_prod_sku_bi
BEFORE INSERT ON productos
FOR EACH ROW
BEGIN
  IF :NEW.codigo_producto IS NULL THEN
    :NEW.codigo_producto := fn_gen_sku(:NEW.id_categoria);
  END IF;
END;
/

-- FK tardía de descuentos a producto (después de crear productos)
ALTER TABLE descuentos
  ADD CONSTRAINT fk_desc_prod FOREIGN KEY (id_producto) REFERENCES productos(id_producto);

-- =====================================================================================
--  INVENTARIO Y COMPRAS
-- =====================================================================================

CREATE TABLE detalle_compras (
  id_detalle_compra   NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_compra           NUMBER NOT NULL,
  id_producto         NUMBER NOT NULL,
  cantidad            NUMBER(12,2) NOT NULL CHECK (cantidad > 0),
  precio_unitario     NUMBER(12,2) NOT NULL CHECK (precio_unitario >= 0),
  descuento_unitario  NUMBER(12,2) DEFAULT 0 NOT NULL CHECK (descuento_unitario >= 0),
  -- virtual calculada desde columnas base
  subtotal            NUMBER(12,2) GENERATED ALWAYS AS (
                         (cantidad * precio_unitario) - descuento_unitario
                       ) VIRTUAL,
  impuesto            NUMBER(12,2) DEFAULT 0 NOT NULL CHECK (impuesto >= 0),
  -- virtual calculada DIRECTO desde columnas base (sin usar subtotal)
  total_linea         NUMBER(12,2) GENERATED ALWAYS AS (
                         (cantidad * precio_unitario) - descuento_unitario + impuesto
                       ) VIRTUAL,
  fecha_registro      TIMESTAMP DEFAULT SYSTIMESTAMP,
  CONSTRAINT fk_dc_compra FOREIGN KEY (id_compra)   REFERENCES compras(id_compra),
  CONSTRAINT fk_dc_prod   FOREIGN KEY (id_producto) REFERENCES productos(id_producto)
);


CREATE TABLE detalle_compras (
  id_detalle_compra NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_compra         NUMBER NOT NULL,
  id_producto       NUMBER NOT NULL,
  cantidad          NUMBER(12,2) NOT NULL CHECK (cantidad > 0),
  precio_unitario   NUMBER(12,2) NOT NULL CHECK (precio_unitario >= 0),
  descuento_unitario NUMBER(12,2) DEFAULT 0 NOT NULL CHECK (descuento_unitario >= 0),
  subtotal          NUMBER(12,2) GENERATED ALWAYS AS (cantidad * precio_unitario - descuento_unitario) VIRTUAL,
  impuesto          NUMBER(12,2) DEFAULT 0 NOT NULL,
  total_linea       NUMBER(12,2) GENERATED ALWAYS AS (subtotal + impuesto) VIRTUAL,
  fecha_registro    TIMESTAMP DEFAULT SYSTIMESTAMP,
  CONSTRAINT fk_dc_compra FOREIGN KEY (id_compra)   REFERENCES compras(id_compra),
  CONSTRAINT fk_dc_prod   FOREIGN KEY (id_producto) REFERENCES productos(id_producto)
);

CREATE TABLE movimientos_inventario (
  id_movimiento    NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_producto      NUMBER NOT NULL,
  tipo_movimiento  CHAR(1) NOT NULL CHECK (tipo_movimiento IN ('E','S','A')), -- Entrada/Salida/Ajuste
  cantidad         NUMBER(12,2) NOT NULL CHECK (cantidad > 0),
  referencia       VARCHAR2(60),     -- p.ej., VENTA:123, COMPRA:456
  motivo           VARCHAR2(200),
  id_almacen       NUMBER,
  stock_anterior   NUMBER(12,2),
  stock_nuevo      NUMBER(12,2),
  fecha_movimiento TIMESTAMP DEFAULT SYSTIMESTAMP,
  CONSTRAINT fk_mov_prod FOREIGN KEY (id_producto) REFERENCES productos(id_producto),
  CONSTRAINT fk_mov_alma FOREIGN KEY (id_almacen)  REFERENCES almacenes(id_almacen)
);

-- =====================================================================================
--  VENTAS (POS)
-- =====================================================================================

CREATE TABLE metodos_pago (
  id_metodo_pago  NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre_metodo   VARCHAR2(60) NOT NULL UNIQUE,
  descripcion     VARCHAR2(200),
  estado          CHAR(1) DEFAULT 'A' CHECK (estado IN ('A','I')),
  fecha_creacion  TIMESTAMP DEFAULT SYSTIMESTAMP
);

CREATE TABLE ventas (
  id_venta      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  codigo_venta  VARCHAR2(20) UNIQUE,
  id_usuario    NUMBER NOT NULL,
  id_cliente    NUMBER,
  id_metodo_pago NUMBER,
  fecha_venta   TIMESTAMP DEFAULT SYSTIMESTAMP,
  descuento_total NUMBER(12,2) DEFAULT 0 NOT NULL,
  impuesto      NUMBER(12,2) DEFAULT 0 NOT NULL,
  subtotal      NUMBER(12,2) DEFAULT 0 NOT NULL,
  total         NUMBER(12,2) DEFAULT 0 NOT NULL,
  observacion   VARCHAR2(300),
  estado        VARCHAR2(20) DEFAULT 'REGISTRADA',
  fecha_creacion TIMESTAMP DEFAULT SYSTIMESTAMP,
  CONSTRAINT fk_venta_user FOREIGN KEY (id_usuario)     REFERENCES usuarios(id_usuario),
  CONSTRAINT fk_venta_cli  FOREIGN KEY (id_cliente)     REFERENCES clientes(id_cliente),
  CONSTRAINT fk_venta_pago FOREIGN KEY (id_metodo_pago) REFERENCES metodos_pago(id_metodo_pago)
);

CREATE SEQUENCE seq_cod_venta START WITH 1 INCREMENT BY 1 NOCACHE;
CREATE OR REPLACE TRIGGER trg_venta_codigo_bi
BEFORE INSERT ON ventas
FOR EACH ROW
BEGIN
  IF :NEW.codigo_venta IS NULL THEN
    :NEW.codigo_venta := 'V' || TO_CHAR(seq_cod_venta.NEXTVAL, 'FM000000');
  END IF;
END;
/

CREATE TABLE detalle_ventas (
  id_detalle_venta    NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_venta            NUMBER NOT NULL,
  id_producto         NUMBER NOT NULL,
  cantidad            NUMBER(12,2) NOT NULL CHECK (cantidad > 0),
  precio_unitario     NUMBER(12,2) NOT NULL CHECK (precio_unitario >= 0),
  descuento_unitario  NUMBER(12,2) DEFAULT 0 NOT NULL CHECK (descuento_unitario >= 0),
  subtotal            NUMBER(12,2) GENERATED ALWAYS AS (
                         (cantidad * precio_unitario) - descuento_unitario
                       ) VIRTUAL,
  impuesto            NUMBER(12,2) DEFAULT 0 NOT NULL CHECK (impuesto >= 0),
  total_linea         NUMBER(12,2) GENERATED ALWAYS AS (
                         (cantidad * precio_unitario) - descuento_unitario + impuesto
                       ) VIRTUAL,
  fecha_registro      TIMESTAMP DEFAULT SYSTIMESTAMP,
  CONSTRAINT fk_dv_venta FOREIGN KEY (id_venta)    REFERENCES ventas(id_venta),
  CONSTRAINT fk_dv_prod  FOREIGN KEY (id_producto) REFERENCES productos(id_producto)
);

-- =====================================================================================
--  ÍNDICES ÚTILES
-- =====================================================================================
CREATE INDEX ix_prod_nombre   ON productos (nombre_producto);
CREATE INDEX ix_prod_categoria ON productos (id_categoria);
CREATE INDEX ix_ventas_fecha  ON ventas (fecha_venta);
CREATE INDEX ix_mov_prod_fecha ON movimientos_inventario (id_producto, fecha_movimiento);
CREATE INDEX ix_clientes_nombre ON clientes (nombre_cliente);

-- =====================================================================================
--  DATOS BÁSICOS (semilla mínima)
-- =====================================================================================
INSERT INTO roles (nombre_rol, descripcion) VALUES ('admin','Administrador');
INSERT INTO roles (nombre_rol, descripcion) VALUES ('vendedor','Vendedor POS');

INSERT INTO metodos_pago (nombre_metodo) VALUES ('Efectivo');
INSERT INTO metodos_pago (nombre_metodo) VALUES ('SINPE Móvil');
INSERT INTO metodos_pago (nombre_metodo) VALUES ('Tarjeta');

COMMIT;


GRANT EXECUTE ON SYS.DBMS_RANDOM TO tienda;
GRANT CREATE ANY SEQUENCE TO tienda;
GRANT SELECT ANY TABLE TO tienda;
GRANT SELECT ANY SEQUENCE TO tienda;


--------------------------------------------------------------------------------
-- Helpers: generar salt y hashear contraseña (SHA-256) sin requerir DBMS_CRYPTO
--------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION fn_auth_make_salt RETURN VARCHAR2 IS
  v_salt VARCHAR2(32);
BEGIN
  -- 16 chars alfanum, suficiente como salt
  v_salt := DBMS_RANDOM.STRING('x', 16);
  RETURN v_salt;
END;
/

CREATE OR REPLACE FUNCTION fn_auth_hash(p_password VARCHAR2, p_salt VARCHAR2)
RETURN VARCHAR2
IS
  v_hex VARCHAR2(64);
BEGIN
  -- Hash = RAWTOHEX( SHA256( password || salt ) )
  v_hex := RAWTOHEX( STANDARD_HASH( p_password || p_salt, 'SHA256' ) );
  RETURN v_hex;
END;
/

--------------------------------------------------------------------------------
-- REGISTER: crea usuario + asigna rol/empresa + registra actividad
--------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE sp_auth_register(
  p_nombre       IN  VARCHAR2,
  p_usuario      IN  VARCHAR2,
  p_email        IN  VARCHAR2,
  p_contrasena   IN  VARCHAR2,
  p_telefono     IN  VARCHAR2,
  p_id_empresa   IN  NUMBER,
  p_id_rol       IN  NUMBER,
  p_id_usuario   OUT NUMBER
) AS
  v_cnt  NUMBER;
  v_salt VARCHAR2(32);
  v_hash VARCHAR2(64);
BEGIN
  -- Validaciones básicas de unicidad
  SELECT COUNT(*) INTO v_cnt FROM usuarios WHERE LOWER(usuario) = LOWER(p_usuario);
  IF v_cnt > 0 THEN
    RAISE_APPLICATION_ERROR(-20010, 'El usuario ya existe.');
  END IF;

  SELECT COUNT(*) INTO v_cnt FROM usuarios WHERE LOWER(email) = LOWER(p_email);
  IF v_cnt > 0 THEN
    RAISE_APPLICATION_ERROR(-20011, 'El email ya está registrado.');
  END IF;

  -- Sal y hash
  v_salt := fn_auth_make_salt();
  v_hash := fn_auth_hash(p_contrasena, v_salt);

  -- Crear usuario (estado A por defecto según tu DDL)
  INSERT INTO usuarios (nombre, usuario, email, contrasena_hash, telefono)
  VALUES (p_nombre, p_usuario, p_email, v_salt || ':' || v_hash, p_telefono)
  RETURNING id_usuario INTO p_id_usuario;

  -- Asignar a empresa y rol
  INSERT INTO usuarios_empresas (id_usuario, id_empresa, id_rol)
  VALUES (p_id_usuario, p_id_empresa, p_id_rol);

  -- Log actividad
  INSERT INTO log_actividades (id_usuario, modulo, accion, objeto, descripcion, ip_origen)
  VALUES (p_id_usuario, 'SEGURIDAD', 'REGISTER', 'USUARIOS', 'Registro de usuario', 'LOCAL');

  COMMIT;
EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
    RAISE;
END;
/

--------------------------------------------------------------------------------
-- LOGIN: valida credenciales + estado + registra sesión y actividad
--------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE sp_auth_login(
  p_usuario_o_email IN  VARCHAR2,
  p_contrasena      IN  VARCHAR2,
  p_ip              IN  VARCHAR2,
  p_dispositivo     IN  VARCHAR2,
  p_id_sesion       OUT NUMBER,
  p_id_usuario      OUT NUMBER
) AS
  v_hash_stored   VARCHAR2(200);
  v_salt          VARCHAR2(64);
  v_hash_input    VARCHAR2(64);
  v_estado        CHAR(1);
BEGIN
  -- Obtener usuario por username o email
  SELECT u.id_usuario, u.contrasena_hash, u.estado
    INTO p_id_usuario, v_hash_stored, v_estado
    FROM usuarios u
   WHERE LOWER(u.usuario) = LOWER(p_usuario_o_email)
      OR LOWER(u.email)   = LOWER(p_usuario_o_email);

  IF v_estado <> 'A' THEN
    RAISE_APPLICATION_ERROR(-20020, 'Usuario inactivo o bloqueado.');
  END IF;

  -- Separar salt y hash guardado (formato SALT:HASH)
  v_salt := SUBSTR(v_hash_stored, 1, INSTR(v_hash_stored, ':') - 1);
  v_hash_input := fn_auth_hash(p_contrasena, v_salt);

  IF v_hash_stored <> v_salt || ':' || v_hash_input THEN
    RAISE_APPLICATION_ERROR(-20021, 'Credenciales inválidas.');
  END IF;

  -- Registrar sesión
  INSERT INTO log_sesiones (id_usuario, ip_origen, dispositivo, descripcion, estado)
  VALUES (p_id_usuario, p_ip, p_dispositivo, 'Inicio de sesión', 'INICIADA')
  RETURNING id_sesion INTO p_id_sesion;

  -- Log actividad
  INSERT INTO log_actividades (id_usuario, modulo, accion, objeto, descripcion, ip_origen)
  VALUES (p_id_usuario, 'SEGURIDAD', 'LOGIN', 'USUARIOS', 'Inicio de sesión', p_ip);

  COMMIT;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20022, 'Usuario no encontrado.');
  WHEN OTHERS THEN
    ROLLBACK;
    RAISE;
END;
/

--------------------------------------------------------------------------------
-- LOGOUT: cierra la sesión y la marca como CERRADA
--------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE sp_auth_logout(
  p_id_sesion IN NUMBER
) AS
  v_user NUMBER;
BEGIN
  UPDATE log_sesiones
     SET fecha_cierre = SYSTIMESTAMP,
         estado       = 'CERRADA'
   WHERE id_sesion    = p_id_sesion
   RETURNING id_usuario INTO v_user;

  IF SQL%ROWCOUNT = 0 THEN
    RAISE_APPLICATION_ERROR(-20030, 'Sesión no encontrada.');
  END IF;

  INSERT INTO log_actividades (id_usuario, modulo, accion, objeto, descripcion, ip_origen)
  VALUES (v_user, 'SEGURIDAD', 'LOGOUT', 'USUARIOS', 'Cierre de sesión', 'LOCAL');

  COMMIT;
EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
    RAISE;
END;
/
SHOW ERRORS;

SHOW ERRORS FUNCTION fn_auth_hash;

SELECT line, position, text
FROM user_errors
WHERE name = 'FN_AUTH_HASH'
ORDER BY sequence;


SHOW USER;
-- Funciones y SPs
SELECT object_name, object_type, status
FROM user_objects
WHERE object_type IN ('FUNCTION','PROCEDURE')
  AND object_name IN ('FN_AUTH_MAKE_SALT','FN_AUTH_HASH','SP_AUTH_REGISTER','SP_AUTH_LOGIN','SP_AUTH_LOGOUT')
ORDER BY object_type, object_name;

SHOW ERRORS PROCEDURE sp_auth_register;
SHOW ERRORS PROCEDURE sp_auth_login;

SELECT line, position, text
FROM user_errors
WHERE name IN ('SP_AUTH_REGISTER','SP_AUTH_LOGIN')
ORDER BY name, sequence;

CREATE OR REPLACE FUNCTION fn_auth_hash(p_password VARCHAR2, p_salt VARCHAR2)
RETURN VARCHAR2
IS
  v_raw RAW(2000);
BEGIN
  -- SHA-256(password || salt), en minúsculas para comparación consistente
  v_raw := UTL_RAW.CAST_TO_RAW(p_password || p_salt);
  RETURN LOWER(RAWTOHEX(DBMS_CRYPTO.HASH(v_raw, DBMS_CRYPTO.HASH_SH256)));
END;
/
SHOW ERRORS;


SELECT fn_auth_hash('test','abc') AS h FROM dual;

ALTER PROCEDURE sp_auth_register COMPILE;
ALTER PROCEDURE sp_auth_login    COMPILE;

SELECT object_name, object_type, status
FROM user_objects
WHERE object_name IN ('SP_AUTH_REGISTER','SP_AUTH_LOGIN','SP_AUTH_LOGOUT','FN_AUTH_HASH');


-- Semilla mínima (si no existen)
MERGE INTO roles r USING (SELECT 'admin' n FROM dual) s ON (LOWER(r.nombre_rol)=s.n)
WHEN NOT MATCHED THEN INSERT (nombre_rol) VALUES ('admin');

MERGE INTO empresas e USING (SELECT 'Mi Empresa' n FROM dual) s ON (LOWER(e.nombre)=LOWER(s.n))
WHEN NOT MATCHED THEN INSERT (nombre) VALUES ('Mi Empresa');
COMMIT;

-- Register
SET SERVEROUTPUT ON
DECLARE
  v_empresa NUMBER;
  v_rol     NUMBER;
  v_user    NUMBER;
BEGIN
  SELECT id_empresa INTO v_empresa FROM empresas WHERE nombre = 'Mi Empresa';
  SELECT id_rol     INTO v_rol     FROM roles    WHERE nombre_rol = 'admin';

  sp_auth_register(
    p_nombre      => 'Yasser',
    p_usuario     => 'yasser',
    p_email       => 'yasser@demo.com',
    p_contrasena  => 'Secreta123',
    p_telefono    => '8888-8888',
    p_id_empresa  => v_empresa,
    p_id_rol      => v_rol,
    p_id_usuario  => v_user
  );

  DBMS_OUTPUT.PUT_LINE('Nuevo usuario ID = '||v_user);
END;

-- Login
VAR v_sesion NUMBER
VAR v_uid    NUMBER
EXEC sp_auth_login('yasser','Secreta123','127.0.0.1','VSCode',:v_sesion,:v_uid);
PRINT v_sesion
PRINT v_uid

-- Logout
EXEC sp_auth_logout(:v_sesion);


-- Prueba de login
VAR v_sesion NUMBER
VAR v_uid    NUMBER
EXEC sp_auth_login('yasser','Secreta123','127.0.0.1','VSCode', :v_sesion, :v_uid);
PRINT v_sesion
PRINT v_uid 